using System;
using System.ServiceModel;
using Unity;
using Unity.Injection;

namespace POCServices.Utility
{
    ///<summary>
    ///
    /// The URL used to generate the reference is stored in the generated code (.svcmap). If the reference is updated then the original URL is used.
    /// This can cause problems if the original URL is old or refers to a developer’s machine.
    /// Even worse is that changing the URL in order to regenerate the reference causes all the files to change even if there is no actual code changes involved.
    ///
    ///
    /// 1) While WCF uses interfaces to hide the implementation details, the generated code actually contains a different
    /// interface that happens to share the same name. The interface is defined in the service reference code.
    /// This makes using the original interface across projects more difficult.

    /// 2) Even worse is that some of the method signatures may be changed. For example enumerables
    /// and collections get converted to arrays, by default. Parameters can even be moved around.

    /// 3) In Visual Studio you can use Find All References to find all references to types and members.
    /// But if you are using service references then FAR won’t detect them because, again, the
    /// service reference generate a new interface.

    /// 4) Any data contracts that are pulled over are modified as well. They include properties
    ///    that are not on the original object. If any code uses these properties then they are now
    ///    using infrastructure provided by WCF which makes unit testing harder.
    /// 
    /// 5) Don’t even think about sharing data that was generated by a service reference in one
    ///    project with any other project (even if it is the same service). The types are different
    ///    to the compiler irrelevant of their name.
    /// 
    /// 6) The whole reason WCF uses interfaces is for abstraction but because of how service
    ///    references work there is no easy way to abstract the actual usage of the service. </summary>

    public static class ServiceFactory
    {
        private static IUnityContainer serviceContainer;

        static ServiceFactory()
        {
            serviceContainer = new UnityContainer();
        }

        private static TService CreateChannel<TService>()
        {
            ChannelFactory<TService> factory = null;
            if (!serviceContainer.IsRegistered<ChannelFactory<TService>>())
            {
                serviceContainer.RegisterType<ChannelFactory<TService>>(new InjectionConstructor(typeof(TService).Name));
            }

            factory = serviceContainer.Resolve<ChannelFactory<TService>>();
            return factory.CreateChannel();
        }

        /// <summary>
        /// Creates a service Channel for <typeparamref name="TService"/> and invokes a method and
        /// returns the result. Endpoint must match the <typeparamref name="TService"/> Name
        /// </summary>
        /// <typeparam name="TReturn">Result Type</typeparam>
        /// <typeparam name="TService">Service Contract to be invoked</typeparam>
        /// <param name="action">Function delegate to be executed on the service</param>
        /// <returns>Result of the <paramref name="action"/> of type <typeparamref name="TResult"/></returns>
        public static TReturn InvokeService<TService, TReturn>(Func<TService, TReturn> action)
           where TService : class
        {
            ICommunicationObject client = (ICommunicationObject)CreateChannel<TService>();
            try
            {
                TReturn result = action(client as TService);
                client.Close();
                return result;
            }
            catch (CommunicationException e)
            {
                client.Abort();
                throw;
            }
            catch (TimeoutException e)
            {
                client.Abort();
                throw;
            }
            catch (Exception e)
            {
                client.Abort();
                throw;
            }
        }

        public static void InvokeService<TService>(Action<TService> action)
        where TService : class
        {
            ICommunicationObject client = (ICommunicationObject)CreateChannel<TService>();
            try
            {
                action(client as TService);
                client.Close();
            }
            catch (CommunicationException e)
            {
                client.Abort();
            }
            catch (TimeoutException e)
            {
                client.Abort();
            }
            catch (Exception e)
            {
                client.Abort();
                throw;
            }
        }
    }
}